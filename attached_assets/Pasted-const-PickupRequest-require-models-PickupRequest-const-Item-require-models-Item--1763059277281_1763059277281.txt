const PickupRequest = require('../models/PickupRequest');
const Item = require('../models/Item');
const User = require('../models/User');
const Notification = require('../models/Notification');
const inventoryService = require('../services/inventoryService');

// Create a pickup request
const createPickupRequest = async (req, res) => {
  try {
    const { itemId, message } = req.body;
    const requesterId = req.user.userId;
    
    if (!itemId) {
      return res.status(400).json({ error: 'Item ID is required' });
    }
    
    // Fetch the item
    const item = await Item.findById(itemId).populate('user');
    
    if (!item) {
      return res.status(404).json({ error: 'Item not found' });
    }
    
    // Check if requester is the seller
    if (item.user._id.toString() === requesterId) {
      return res.status(400).json({ error: 'You cannot request your own item' });
    }
    
    // Check if item is available - only allow requests on 'available' items
    if (item.status !== 'available') {
      return res.status(400).json({ 
        error: `This item is no longer available (status: ${item.status})` 
      });
    }
    
    // For store items, also check if they have stock
    if (item.isStoreItem && item.quantity !== null && item.quantity <= 0) {
      return res.status(400).json({ 
        error: 'This store item is out of stock' 
      });
    }
    
    // Check if there's already a pending or awaiting_pickup request from this user
    const existingRequest = await PickupRequest.findOne({
      item: itemId,
      requester: requesterId,
      status: { $in: ['pending', 'awaiting_pickup'] }
    });
    
    if (existingRequest) {
      return res.status(400).json({ 
        error: 'You already have an active request for this item',
        requestId: existingRequest._id
      });
    }
    
    // Determine request type based on item
    const requestType = item.isFree ? 'free' : 'paid';
    
    // For paid items, verify payment was made (check buyerId or payment status)
    if (requestType === 'paid') {
      // Check if user has purchased this item
      if (!item.buyerId || item.buyerId.toString() !== requesterId) {
        return res.status(400).json({ 
          error: 'You must purchase this item before requesting pickup'
        });
      }
    }
    
    // Create the pickup request
    const pickupRequest = new PickupRequest({
      item: itemId,
      requester: requesterId,
      seller: item.user._id,
      requestType,
      status: 'pending',
      amountPaid: requestType === 'paid' ? item.price : 0
    });
    
    await pickupRequest.save();
    
    // Populate for response
    await pickupRequest.populate([
      { path: 'item', select: 'name imageURL price isFree' },
      { path: 'requester', select: 'name email' },
      { path: 'seller', select: 'name email' }
    ]);
    
    // Create notification for seller
    const notification = new Notification({
      user: item.user._id,
      type: 'pickup_request',
      message: `${pickupRequest.requester.name} wants to ${requestType === 'free' ? 'pick up' : 'collect'} your item "${item.name}"`,
      relatedItem: itemId,
      relatedUser: requesterId,
      metadata: {
        requestId: pickupRequest._id,
        requestType,
        itemName: item.name,
        requesterName: pickupRequest.requester.name,
        customMessage: message || null
      }
    });
    
    await notification.save();
    
    res.status(201).json({
      success: true,
      message: 'Pickup request sent successfully',
      request: {
        id: pickupRequest._id,
        itemId: item._id,
        itemName: item.name,
        status: pickupRequest.status,
        requestType: pickupRequest.requestType,
        seller: {
          id: pickupRequest.seller._id,
          name: pickupRequest.seller.name
        },
        createdAt: pickupRequest.createdAt
      }
    });
    
  } catch (error) {
    console.error('Create pickup request error:', error);
    res.status(500).json({ 
      error: 'Failed to create pickup request',
      details: error.message 
    });
  }
};

// Get all pickup requests (filtered by role)
const getPickupRequests = async (req, res) => {
  try {
    const userId = req.user.userId;
    const { role, status } = req.query; // role: 'seller' or 'requester'
    
    let query = {};
    
    // Build query based on role
    if (role === 'seller') {
      query.seller = userId;
    } else if (role === 'requester') {
      query.requester = userId;
    } else {
      // Default: get all requests where user is either seller or requester
      query.$or = [
        { seller: userId },
        { requester: userId }
      ];
    }
    
    // Filter by status if provided
    if (status) {
      query.status = status;
    }
    
    const requests = await PickupRequest.find(query)
      .populate('item', 'name imageURL price isFree location address')
      .populate('requester', 'name email')
      .populate('seller', 'name email')
      .sort({ createdAt: -1 });
    
    // Format response - filter out requests with missing data (deleted items/users)
    const formattedRequests = requests
      .filter(req => req.item && req.requester && req.seller) // Skip if any critical data is null
      .map(req => ({
        id: req._id,
        item: {
          id: req.item._id,
          name: req.item.name,
          imageURL: req.item.imageURL,
          price: req.item.price,
          isFree: req.item.isFree
        },
        requester: {
          id: req.requester._id,
          name: req.requester.name,
          email: req.requester.email
        },
        seller: {
          id: req.seller._id,
          name: req.seller.name,
          email: req.seller.email
        },
        requestType: req.requestType,
        status: req.status,
        deliveryMode: req.deliveryMode,
        sellerAddress: req.sellerAddress,
        sellerInstructions: req.sellerInstructions,
        buyerConfirmed: req.buyerConfirmed,
        sellerConfirmed: req.sellerConfirmed,
        amountPaid: req.amountPaid,
        createdAt: req.createdAt,
        acceptedAt: req.acceptedAt,
        completedAt: req.completedAt
      }));
    
    res.json({
      success: true,
      count: formattedRequests.length,
      requests: formattedRequests
    });
    
  } catch (error) {
    console.error('Get pickup requests error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch pickup requests',
      details: error.message 
    });
  }
};

// Accept a pickup request
const acceptPickupRequest = async (req, res) => {
  try {
    const { requestId } = req.params;
    const { deliveryMode, address, instructions } = req.body;
    const userId = req.user.userId;
    
    if (!deliveryMode || !address) {
      return res.status(400).json({ 
        error: 'Delivery mode and address are required' 
      });
    }
    
    if (!['pickup', 'delivery'].includes(deliveryMode)) {
      return res.status(400).json({ 
        error: 'Invalid delivery mode. Must be "pickup" or "delivery"' 
      });
    }
    
    // Fetch the request
    const pickupRequest = await PickupRequest.findById(requestId)
      .populate('item')
      .populate('requester', 'name email');
    
    if (!pickupRequest) {
      return res.status(404).json({ error: 'Pickup request not found' });
    }
    
    // Verify user is the seller (convert both to strings for comparison)
    if (pickupRequest.seller.toString() !== userId.toString()) {
      return res.status(403).json({ 
        error: 'You are not authorized to accept this request'
      });
    }
    
    // Check if request is still pending
    if (pickupRequest.status !== 'pending') {
      return res.status(400).json({ 
        error: `Cannot accept request with status: ${pickupRequest.status}` 
      });
    }
    
    // Accept the request (this sets request status to 'awaiting_pickup')
    await pickupRequest.accept(deliveryMode, address, instructions);
    
    // Update item status to match
    await Item.findByIdAndUpdate(pickupRequest.item._id, {
      status: 'awaiting_pickup'
    });
    
    // Create notification for requester
    const notification = new Notification({
      user: pickupRequest.requester._id,
      type: 'request_accepted',
      message: `Your pickup request for "${pickupRequest.item.name}" has been accepted!`,
      relatedItem: pickupRequest.item._id,
      relatedUser: userId,
      metadata: {
        requestId: pickupRequest._id,
        deliveryMode,
        address,
        instructions,
        itemName: pickupRequest.item.name
      }
    });
    
    await notification.save();
    
    res.json({
      success: true,
      message: 'Pickup request accepted successfully',
      request: {
        id: pickupRequest._id,
        status: pickupRequest.status,
        deliveryMode: pickupRequest.deliveryMode,
        sellerAddress: pickupRequest.sellerAddress,
        sellerInstructions: pickupRequest.sellerInstructions,
        acceptedAt: pickupRequest.acceptedAt
      }
    });
    
  } catch (error) {
    console.error('Accept pickup request error:', error);
    res.status(500).json({ 
      error: 'Failed to accept pickup request',
      details: error.message 
    });
  }
};

// Decline a pickup request
const declinePickupRequest = async (req, res) => {
  try {
    const { requestId } = req.params;
    const { reason } = req.body;
    const userId = req.user.userId;
    
    // Fetch the request
    const pickupRequest = await PickupRequest.findById(requestId)
      .populate('item', 'name')
      .populate('requester', 'name email');
    
    if (!pickupRequest) {
      return res.status(404).json({ error: 'Pickup request not found' });
    }
    
    // Verify user is the seller (convert both to strings for comparison)
    if (pickupRequest.seller.toString() !== userId.toString()) {
      return res.status(403).json({ 
        error: 'You are not authorized to decline this request' 
      });
    }
    
    // Check if request is still pending
    if (pickupRequest.status !== 'pending') {
      return res.status(400).json({ 
        error: `Cannot decline request with status: ${pickupRequest.status}` 
      });
    }
    
    // Decline the request
    await pickupRequest.decline(reason);
    
    // Create notification for requester
    const notification = new Notification({
      user: pickupRequest.requester._id,
      type: 'request_declined',
      message: `Your pickup request for "${pickupRequest.item.name}" was declined`,
      relatedItem: pickupRequest.item._id,
      relatedUser: userId,
      metadata: {
        requestId: pickupRequest._id,
        reason: reason || 'Seller declined the request',
        itemName: pickupRequest.item.name
      }
    });
    
    await notification.save();
    
    res.json({
      success: true,
      message: 'Pickup request declined',
      request: {
        id: pickupRequest._id,
        status: pickupRequest.status,
        declineReason: pickupRequest.declineReason,
        declinedAt: pickupRequest.declinedAt
      }
    });
    
  } catch (error) {
    console.error('Decline pickup request error:', error);
    res.status(500).json({ 
      error: 'Failed to decline pickup request',
      details: error.message 
    });
  }
};

// Confirm pickup completion (buyer or seller)
const confirmPickupCompletion = async (req, res) => {
  try {
    const { requestId } = req.params;
    const userId = req.user.userId;
    
    // Fetch the request
    const pickupRequest = await PickupRequest.findById(requestId)
      .populate('item', 'name isStoreItem quantity')
      .populate('requester', 'name')
      .populate('seller', 'name');
    
    if (!pickupRequest) {
      return res.status(404).json({ error: 'Pickup request not found' });
    }
    
    // Check if user is buyer or seller (convert both to strings for comparison)
    const isBuyer = pickupRequest.requester._id.toString() === userId.toString();
    const isSeller = pickupRequest.seller._id.toString() === userId.toString();
    
    if (!isBuyer && !isSeller) {
      return res.status(403).json({ 
        error: 'You are not authorized to confirm this request' 
      });
    }
    
    // Check if request is in awaiting_pickup status
    if (pickupRequest.status !== 'awaiting_pickup') {
      return res.status(400).json({ 
        error: `Cannot confirm request with status: ${pickupRequest.status}` 
      });
    }
    
    // Confirm based on role
    if (isBuyer) {
      await pickupRequest.confirmByBuyer();
    } else {
      await pickupRequest.confirmBySeller();
    }
    
    // If both confirmed, handle inventory and status updates
    if (pickupRequest.status === 'completed') {
      // Fetch full item to check if already paid
      const fullItem = await Item.findById(pickupRequest.item._id);
      
      // Only decrement stock for FREE items (paid items already decremented in confirmPayment)
      if (pickupRequest.requestType === 'free') {
        // Use inventory service for atomic stock management
        const stockResult = await inventoryService.decrementStock(fullItem._id, 1);
        
        if (!stockResult.success && stockResult.outOfStock) {
          // Unlikely scenario: item sold out between confirmation steps
          return res.status(400).json({
            error: 'Item is no longer available',
            details: stockResult.message
          });
        }
        
        if (!stockResult.success) {
          console.error('Failed to update inventory:', stockResult.message);
          return res.status(500).json({
            error: 'Exchange completed but inventory update failed',
            details: stockResult.message
          });
        }
        
        // For regular free items (not store items), mark as completed
        if (stockResult.skipQuantity) {
          await Item.findByIdAndUpdate(fullItem._id, {
            status: 'completed'
          });
        }
        // Note: Store items stay 'available' with decremented quantity
      } else {
        // Paid items: Stock already decremented in confirmPayment
        if (fullItem.isStoreItem) {
          // Store items: return to 'available' status (already decremented in confirmPayment)
          await Item.findByIdAndUpdate(fullItem._id, {
            status: 'available'
          });
        } else {
          // Regular items: mark as completed
          await Item.findByIdAndUpdate(fullItem._id, {
            status: 'completed'
          });
        }
      }
      
      // Create notification for the other party
      const otherUserId = isBuyer ? pickupRequest.seller._id : pickupRequest.requester._id;
      const notification = new Notification({
        user: otherUserId,
        type: 'exchange_completed',
        message: `The exchange for "${pickupRequest.item.name}" has been completed! Both parties confirmed.`,
        relatedItem: pickupRequest.item._id,
        relatedUser: userId,
        metadata: {
          requestId: pickupRequest._id,
          itemName: pickupRequest.item.name
        }
      });
      await notification.save();
    } else {
      // Notify the other party that one person confirmed
      const otherUserId = isBuyer ? pickupRequest.seller._id : pickupRequest.requester._id;
      const whoConfirmed = isBuyer ? pickupRequest.requester.name : pickupRequest.seller.name;
      const notification = new Notification({
        user: otherUserId,
        type: 'pickup_confirmed',
        message: `${whoConfirmed} confirmed the pickup for "${pickupRequest.item.name}". Please confirm when complete.`,
        relatedItem: pickupRequest.item._id,
        relatedUser: userId,
        metadata: {
          requestId: pickupRequest._id,
          itemName: pickupRequest.item.name,
          confirmedBy: isBuyer ? 'buyer' : 'seller'
        }
      });
      await notification.save();
    }
    
    res.json({
      success: true,
      message: isBuyer 
        ? 'Pickup confirmed by buyer' 
        : 'Pickup confirmed by seller',
      request: {
        id: pickupRequest._id,
        status: pickupRequest.status,
        buyerConfirmed: pickupRequest.buyerConfirmed,
        sellerConfirmed: pickupRequest.sellerConfirmed,
        isFullyCompleted: pickupRequest.status === 'completed',
        completedAt: pickupRequest.completedAt
      }
    });
    
  } catch (error) {
    console.error('Confirm pickup error:', error);
    res.status(500).json({ 
      error: 'Failed to confirm pickup',
      details: error.message 
    });
  }
};

// Cancel a pickup request (by requester only)
const cancelPickupRequest = async (req, res) => {
  try {
    const { requestId } = req.params;
    const userId = req.user.userId;
    
    // Fetch the request
    const pickupRequest = await PickupRequest.findById(requestId)
      .populate('seller', 'name');
    
    if (!pickupRequest) {
      return res.status(404).json({ error: 'Pickup request not found' });
    }
    
    // Verify user is the requester (convert both to strings for comparison)
    if (pickupRequest.requester.toString() !== userId.toString()) {
      return res.status(403).json({ 
        error: 'You are not authorized to cancel this request' 
      });
    }
    
    // Can only cancel pending or awaiting_pickup requests
    if (!['pending', 'awaiting_pickup'].includes(pickupRequest.status)) {
      return res.status(400).json({ 
        error: `Cannot cancel request with status: ${pickupRequest.status}` 
      });
    }
    
    // Fetch the full item to check its status
    const item = await Item.findById(pickupRequest.item);
    
    // Cancel the request
    pickupRequest.status = 'canceled';
    await pickupRequest.save();
    
    // If item was in awaiting_pickup state, reset it to available
    if (item && item.status === 'awaiting_pickup') {
      await Item.findByIdAndUpdate(item._id, {
        status: 'available'
      });
    }
    
    // Notify seller
    const notification = new Notification({
      user: pickupRequest.seller._id,
      type: 'request_canceled',
      message: `A pickup request for "${item ? item.name : 'an item'}" was canceled`,
      relatedItem: item ? item._id : pickupRequest.item,
      relatedUser: userId,
      metadata: {
        requestId: pickupRequest._id,
        itemName: item ? item.name : 'Unknown'
      }
    });
    
    await notification.save();
    
    res.json({
      success: true,
      message: 'Pickup request canceled',
      request: {
        id: pickupRequest._id,
        status: pickupRequest.status
      }
    });
    
  } catch (error) {
    console.error('Cancel pickup request error:', error);
    res.status(500).json({ 
      error: 'Failed to cancel pickup request',
      details: error.message 
    });
  }
};

// Get a single pickup request by ID
const getPickupRequestById = async (req, res) => {
  try {
    const { requestId } = req.params;
    const userId = req.user.userId;
    
    const pickupRequest = await PickupRequest.findById(requestId)
      .populate('item', 'name imageURL price isFree location address')
      .populate('requester', 'name email')
      .populate('seller', 'name email');
    
    if (!pickupRequest) {
      return res.status(404).json({ error: 'Pickup request not found' });
    }
    
    // Verify user is involved in this request (convert both to strings for comparison)
    const isRequester = pickupRequest.requester._id.toString() === userId.toString();
    const isSeller = pickupRequest.seller._id.toString() === userId.toString();
    
    if (!isRequester && !isSeller) {
      return res.status(403).json({ 
        error: 'You are not authorized to view this request' 
      });
    }
    
    res.json({
      success: true,
      request: {
        id: pickupRequest._id,
        item: {
          id: pickupRequest.item._id,
          name: pickupRequest.item.name,
          imageURL: pickupRequest.item.imageURL,
          price: pickupRequest.item.price,
          isFree: pickupRequest.item.isFree
        },
        requester: {
          id: pickupRequest.requester._id,
          name: pickupRequest.requester.name,
          email: pickupRequest.requester.email
        },
        seller: {
          id: pickupRequest.seller._id,
          name: pickupRequest.seller.name,
          email: pickupRequest.seller.email
        },
        requestType: pickupRequest.requestType,
        status: pickupRequest.status,
        deliveryMode: pickupRequest.deliveryMode,
        sellerAddress: pickupRequest.sellerAddress,
        sellerInstructions: pickupRequest.sellerInstructions,
        buyerConfirmed: pickupRequest.buyerConfirmed,
        sellerConfirmed: pickupRequest.sellerConfirmed,
        amountPaid: pickupRequest.amountPaid,
        declineReason: pickupRequest.declineReason,
        createdAt: pickupRequest.createdAt,
        acceptedAt: pickupRequest.acceptedAt,
        declinedAt: pickupRequest.declinedAt,
        completedAt: pickupRequest.completedAt
      }
    });
    
  } catch (error) {
    console.error('Get pickup request by ID error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch pickup request',
      details: error.message 
    });
  }
};

module.exports = {
  createPickupRequest,
  getPickupRequests,
  getPickupRequestById,
  acceptPickupRequest,
  declinePickupRequest,
  confirmPickupCompletion,
  cancelPickupRequest
};